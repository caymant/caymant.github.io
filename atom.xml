<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caymant</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/caymant/"/>
  <updated>2018-06-30T01:53:08.773Z</updated>
  <id>https://github.com/caymant/</id>
  
  <author>
    <name>xudong tao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图论在数据结构中的应用</title>
    <link href="https://github.com/caymant/2018/04/20/%E5%9B%BE%E8%AE%BA%E5%9C%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://github.com/caymant/2018/04/20/图论在数据结构中的应用/</id>
    <published>2018-04-20T04:58:43.000Z</published>
    <updated>2018-06-30T01:53:08.773Z</updated>
    
    <content type="html"><![CDATA[<p>1　　前言<br>图论是一门既古老又年轻的学科[1]，说它古老，是因为图论从产生到现在已经有200多年的历史了[1]；说它年轻，是因为近几十年来图论随着计算机技术的快速发展表现出了蓬勃的生命力。图论是数学很重要的一个分支。离散数学中大部分内容都来源于图论。其主要研究对象就是图。现实生活中的大部分问题都可以归结为图的问题[9]。因此，图论在未来的应用空间非常广阔。图论广泛应用于物理学、生物学、电力工程、运筹学以及社会科学，尤其是在计算机科学中的应用[1]。图论作为理论基础奠定了计算机科学的发展，而计算机作为图论解决实际问题的载体又使图论成为数学领域发展最快速的学科分支。可以说，图论沟通了计算机和数学，并使一个古老的学科和一个新兴的学科有机的组合成长，不断的为人类社会做出突出贡献。<br>1.1　图论的发展历史与现状<br>　　图论从起源到现在可以划分为三个阶段：第一阶段是从十八世纪前中期到十九世纪中期。当时，图论主要围绕迷宫问题和游戏问题。最著名的研究是数学家欧拉解决的哥尼斯堡七桥问题。所以欧拉被称为图论之父。欧拉将这七个桥梁的问题抽象为了一笔画问题。第二阶段是19世纪中叶到20世纪中叶。图论的主要研究问题主要是游戏问题，如：游戏问题、迷宫问题、棋盘上的行走路线等[1]。1847年，德国的G.R. Kirchoff用图论分析了电网络，给出了驱动点阻抗和转移导纳的拓扑公式[16]。这是将图论应用到工程技术领域的第一篇论文[13]。1857年，英国A.Cayle也独立地提出了树的概念，并将其应用于有机化合物的分子结构的研究[3]。在1936，匈牙利数学家D. König写了他的第一本理论书， 《有向图和无向图理论》[13]。图式理论是一门独立的学科。第三阶段是在1936之后。自从二十世纪以来，图论已经成为数学发展最快的分支之一。将图论应用在生物学、物理学、建筑学、道路规划、计算机软件设计和硬件存储中具有很大的优势。到上世纪三十年代也就是上面所说的第三阶段之后，图论就算已经成为了理论化系统化的学科。但是因为直到上世纪70年代图论才在中国引发关注。在中国甚至整个东亚，华东师范大学李修睦教授算是最早研究图论的了，我国第一部图论方面的书籍《图论导引》正是出自李先生之手，还有，中国科学院数学研究所吴文俊教授、管梅谷教授相应地对图论进行了研究[13]。随后图论不断地在中国越来越受数学界的重视。到了上世纪末，涌现了大批国内研究图论的数学家。他们对图论做出了突出的贡献，例如刘桂真、王树禾、刘彦佩等。<br>1.2　数据结构的发展历史与现状<br>1968年，数据结构首先在国外被视为一门正式学科，但当时数据结构的范围含糊不清。那时候，数据结构几乎被理解为图论，尤其是树和表理论的同义词。然后将数据结构的概念扩展到包括集合代数理论、格、关系、网络等，进而成为当前“离散结构”的内容[2]。但是，由于数据必须在计算机上处理，不仅要考虑数据本身的数学性质，还要考虑数据的存储结构，这进一步扩展了数据结构的内容。近年来,随着数据库系统的不断发展,“数据结构”课程中又增加了文件管理(特别是大型文件的组织等)的内容[2]。<br>1968年，DE Knuth教授创建了原有的“数据结构”系统。《计算机编程技术》的第一部分–《基本算法》是第一本系统地阐述数据的逻辑结构，存储结构和操作的书[2]。从20世纪60年代末到70年代初，软件相对独立。结构化编程已成为编程方法学的主要内容。人们越来越关注“数据结构”[2]。程序设计的本质是为已确定的问题选择一个好的结构，并设计一个好的算法。从七十年代中期到八十年代初，出现了各种版本的数据结构。目前中国非常重视数据结构。几乎所有的工程专业学生都必须学习数据结构。数据结构是一个复杂而广泛覆盖的学科[2]。数据结构不仅需要硬件，还需要数据结构。数据结构被广泛应用于各行各业。并且“数据结构”是计算机硬件，计算机软件和数学三者之间的最重要课程。值得注意的是，数据结构一直是一棵常青树，并且在不断发展。一方面，研究和开发了用数据结构来解决专业领域特殊问题。另一方面，从抽象数据类型的角度来讨论数据结构已经成为一种新趋势，并且数据结构受到了越来越多的关注[2]。<br>1.3　树的发展历史与现状<br>树的结构是图论和数据结构的重要组成部分。它相当于人的骨架、建筑的框架，这种结构所代表的层次结构就像一棵树。对于最先引用树结构的人我们不做过多的考证。毫无疑问，相对而言，非常直观的东西往往不是第一个被引用的，更不用说清晰的发展历史了。但正是因为树的结构可以很好地表示层次关系，就像旧的家庭映射，所以树结构几乎在每一个方面都被使用。早在1847，基尔霍夫就用树来研究电路网络；1857，凯莉通过树的结构研究了分子结构[15]；现在，计算机领域中的主要树结构主要是二叉树、B树等。基于二进制树的数据结构主要用于二进制搜索，二进制排序，AVL应用在进程地址空间的管理，B / B +树应用在硬盘文件结构查找，数据的索引和数据库索引的应用，赫夫曼树的编码标准的应用，字典树在统计和排序中的应用。<br>1.4　本文的主要研究内容<br>图论目前发展迅速，在计算机中得到了大量应用。图论研究了很多经典的问题，其中最著名的难题是四色问题、哈密尔顿问题、和乌拉姆问题[8]。四色问题已于1976年由计算机程序解决，后两者至今仍悬而未决。随着计算机科学的发展，用计算机解决问题是非常有效率的。但是通过解决一个问题往往是很复杂的，建立良好的数学模型和在准确的算法，恰当的数据结构表示缺一不可。图论中的很多理论知识在数据结构中需要大量的应用。直白地说图论中还有大量的语言需要转化为数据结构的语言，而这个问题目前还没有彻底解决。<br>为了解决这些问题，本文主要研究图论中关于查找的一些经典算法是如何应用在数据结构中的。主要内容如下：<br>第一方面：分析二叉树的查找（二叉查找树和平衡二叉树）、Huffman树在数据结构中的定义，存储，应用。首先通过研究图论中树结构的查找在数据结构中的应用。以二叉查找树为例，研究二叉平衡树的查找算法，实现如何将图论中的算法在计算机中通过数据结构的知识得以实现。最后分析了Huffman树的原理，通过Huffman树的权值最小来解决实际问题。<br>第二方面：分析在网状图结构中的查找，以最小生成树算法为例，研究图论的算法在数据结构中的定义，存储，应用。首先给出了图搜索算法的概述，通过图搜索算法衍生出了很多在网状图结构中的查找算法。以Kruskal算法为例子，研究网状图结构在数据结构中的表示以及存储和算法实现。并且通过最小生成树来解决雄安新区道路规划的实例，说明网状图结构的广泛应用。<br>1.5　本文的组织结构<br>第一章为引言，介绍本文要研究内容的发展历史和现状。<br>第二章为预备知识，介绍后续工作所需的有关基本定义、性质和一些符号。<br>第三章首先采用对比的方法讨论二元树结构的几种不同的树，进而统一的研究二叉树查找。最后分析Huffman树在现实中的应用。<br>第四章研究网状图结构中最小生成树的应用。和第三章的树形结构相呼应。分层讨论，相互对应。<br>第五章是对本文的一个总结，以及对图论的展望。尤其是图论在数据结构中的应用的展望。</p><p>2　　预备知识<br>本章主要给出图论中的基本概念和术语，数据结构中的基本概念和术语，以及树结构在图论中的术语，名词表示和在数据结构中的术语，名词表示。本文数据结构主要内容参考文献[2]，图论主要内容参考文献[6]。<br>2.1　图论<br>2.1.1　图的基本概念<br>定义2.1.1.1[1]称数学结构G={V(G),E(G)}为一个图，其中V(G)是非空集合，称G是一个以V(G)为顶点集，E(G)为边集合的图，V(G)中的元素称为图G的顶点，E(G)中的元素称为图G的边。如果一条边e与顶点u，v相关联，可以表示成e=(u,v);其中u,v为e的两个顶点，u与v是相邻的。如果e有方向称为有向边，如果e没方向称为无向边[6]。如果一个图每条边都有方向，称为有向图。反之，若图中任意一条边e=(u,v)=(v,u),则称为无向图。<br>我们给出图论中对于图基本的术语定义：<br>（1）边的端点：e=uv时，称顶u与v是边e的端点。<br>（2）边与顶相关联：若边e的端点是u和v，那么称e与u，v相关联。<br>（3）邻顶：同一条边的两个端点叫做邻顶。<br>（4）邻边：与同一个顶相关联的两条边叫做邻边。<br>（5）环：只与一个顶相关联的边叫做环。<br>（6）单图：无环无重边的图<br>（7）完全图：任两顶皆相邻的图，记为。<br>（8）二分图：,,且X中任二顶不相邻，Y中任二顶<br>（9）对于一个图G=(V,E),它的顶点个数称为阶数,它的边的条数称为边数,<br>分别记为n(G),和m(G)。G=(V,E)中所有和点V相邻的点构成的邻集为,<br>称为点V的度,记为。<br>2.1.2　图论中树的基本概念和术语<br>树的层次结构在检索和分层设计上有很多应用[14]，下面给出树的基本概念和术语介绍。<br>定义2.1.2.1[1] 无圈连通图称为树。每个连通片皆为树的不连通图称为森林；树上次数为1的顶称为叶，如果一个树T是图G的生成子图，则称T是G的生成树。<br>二叉树：二叉树是一个连通的无环图。 每个顶点的度数不大于3.如果根结点存在，那么根结点的度最多为2。<br>引理2.1.2.1[6] G是连通图的充分必要条件是G有生成树。<br>引理2.1.2.2[6] 线图G为树的充要条件是它无回路且连通。<br>引理2.1.2.3[6] 线图F为树的充要条件是它的任两顶之间恰有一条通路。<br>定义2.1.2.2[6] 若T是树，把T的每边标志一个方向，使得除顶外，每个皆存在由到的有向轨，即从出发，沿各边的箭头标志的方向，在上可以行至,则称T为以为根的外向树。<br>定义2.1.2.3[6] 在有向图G中，表示以为尾的边的条数，表示以为头的边的条数。<br>定义2.1.2.4[6] ，若T是外向树，且任一顶，则称T为k元树。<br>定义2.1.2.5[6]  如果一外向树中，每个顶点V的子树按一定次序排列，则称这种外向树为有序树。<br>2.2　数据结构<br>2.2.1　数据结构的基本概念和术语<br>定义2.2.1.1[2] 数据结构的定义：数据结构是一个二元组D=（d,s），其中d是数据元素的有限集，s是d上关系的有限集。<br>定义2.2.1.2[2] 数据的逻辑结构是指反映数据元素之间的逻辑关系的数据结构，逻辑结构包括：1.集合2.线性结构3.树形结构4.图形结构。<br>定义2.2.1.3[2] 数据的物理结构：指数据的逻辑结构在计算机存储空间的存放形式。数据的物理结构是数据结构在计算机中的表示（又称映像），它包括数据元素的机内表示和关系的机内表示。<br>2.2.2　数据结构中树的基本概念和术语<br>定义2.2.2.1[2] 树是n（n&gt;=0）个结点的有限集，在任意一颗非空树中；（1）有且仅有一个特定的称为根的结点；（2）当n&gt;1时其余结点可分为m(m&gt;0)个互不相交的有限集,,…….，其中每一个集合本身又是一棵树，并且称为根的子树。<br>定义2.2.2.2[2] 结点拥有的子树数称为结点的度（Degree）,度为0的结点称为叶子或终端结点。度不为0的结点称为非终端结点或分支结点。树的度是树内各结点的度的最大值。树中结点的最大层次称为数的深度或高度。<br>定义2.2.2.3[2] 二叉树：二叉树是一种树型结构，二叉树的每个结点至多只有两棵子树（二叉树不存在度大于2的结点），二叉树的子树有左右之分，不能颠倒次序。<br>二叉树的相关概念：<br>(1)路径(Path):从树中的一个结点到另一个结点之间的分支构成两个结点间的路径[2]。<br>(2)路径长度(Path Length):路径上的分支树。<br>(3)树的路径长度(Path Length of Tree):从树的根结点到每个结点的路径长度之和。在结点数目相同的二叉树中，完全二叉树的路径长度最短[2]。<br>(4)结点的权(Weight of Node):在一些应用中，赋予树中结点的一个有实际意义的树。<br>(5)结点的带权路径长度(Weight Path Length of Node):从该结点到树的根结点的路径长度与该结点的权的乘积[2]。<br>2.2.3　二元搜索树子类的概念和比较<br>二叉排序树定义和性质：<br>定义2.2.3.1[11] 二叉排序树（BST），又叫二叉查找树。二叉排序树或者是一棵空树，或者是满足以下条件的非空二叉树：<br>①若某结点左子树非空，此结点左子树上所有结点关键字值均小于此结点的关键字值。<br>②若某结点右子树非空，此结点右子树上所有结点关键字值均小于此结点的关键字值。<br>③左子树，右子树都分别也是二叉排序树[11]。<br>定义2.2.3.2[11] 任意结点的左、右子树高度差的绝对值不超过1，这样的二叉树称为平衡二叉树（AVL）。二叉平衡树或者是一棵空树，或者是满足以下条件的非空二叉树：<br>①左子树和右子树都是平衡二叉树。<br>②左子树和右子树的高度差的绝对值不超过1。<br>性质2.2.3.1[11]:<br>1.二叉平衡树结点左子树和右子树的高度差为该结点的平衡因子。<br>2.平衡二叉树结点的平衡因子的值只可能是-1,0或1。<br>3.含有n个结点的平衡二叉树的最大深度为.</p><p>图2-1　　平衡二叉树                 图2-2　　不平衡二叉树</p><p>定义2.2.3.3[11] 以为根，为叶的有序二元树T中，代表的事物出现的概率为，满足，称轨的长为的码长，且使得，则称T为带权的Huffman树，又称最优二叉树。<br>　　引理２.３.３.１若T是Huffman树，，为叶，（1）若与是兄弟，则；（2）与是兄弟；（3）设是带权的Huffman树，与相应的叶子生出两个新叶分别带权与，则得带权的Huffman树。<br>　　哈夫曼树的构造：<br>　　给定n个权值分别为的结点，依据哈夫曼算法可以构造出哈夫曼树，也就是最优二叉树。<br>　　Huffman树算法描述：<br>　　（１）将这n个结点构成的集合，看做n个独立的仅含有一个结点的二叉树构成的森林。<br>　　（２）从森林中选取两个权值最小的结点作为新节点的左右子树来构造一个新结点，并且将新结点的权值置为左右子树结点权值之和。<br>　　（３）从森林中删去刚才作为新结点左右子树的两个结点，同时将新结点加入森林。<br>　　（４）重复步骤（2）（3），直到森林中只剩下一颗树为止。<br>Kuffman树构造过程图形表示：</p><p>图2-3　　Huffman树的构造过程</p><p>平衡二叉树，二叉排序树，Huffman树它们的查找算法相同，只不过平衡二叉树的查找效率是最优的。因为二叉树的查找就是一个和给定值逐层比较的过程，所以比较的关键字次数一定小于或等于树的深度。 平衡二叉树的平均查找长度为，结点数目相同的情况下，二叉平衡树的树深度是最小的，所以查找效率是最优的[12]。</p><p>3　　树型图结构中的查找<br>本章主要讨论图论中树形结构的查找。首先研究二元搜索树中的查找算法，通过分析时间复杂度进而引进平衡二叉树。讨论二元树结构在数据结构中的存储以及算法实现。最后以Huffman树的例子来说明某些二元树结构在现实生活中的大量应用。<br>3.1　二元树在查找中的应用<br>在现实生活中的各个领域，几乎都需要实现数据元素的查找这一步骤。小到我们在自己的笔记本电脑上查找一个文件，在一本书中查找一个章节。大到图书馆中图书的检索，电子商务的商品搜索，搜索引擎的查找等。那么在数据元素的查找中，如果只是单纯的线性查找，算法效率很慢，如果数据量较大的话，显然不切实际。而通过二叉树结构可以有效的提高查找效率。图论中应用在树结构的查找主要是二元树的搜索，对应的数据结构主要是二叉排序树和二叉平衡树。<br>二元树的定义：设    S是一个有序有限集，T是标号二元树。若T中每个顶点v用S中的一个元素标号，使得<br>（1）对v的左子树中每一个顶点u有；<br>（2）对v的右子树中每一个顶点u有；<br>（3）对S中的每一个元素，恰有一个顶点v使得。则称T是集合S的二元搜索树。<br>一个二元树可以用两列数组表示，一列表示左孩子，一列表示右孩子。图3-3可用下表示：表3-1　　二元树的数组表示<br>结点    左孩子    右孩子<br>1    0    0<br>2    1    4<br>3    0    0<br>4    3    0<br>7    2    8<br>8    0    0</p><p>3.1.1　二元搜索树的存储<br>下面将从几种存储结构方式，介绍二元搜索树的存储。<br>1顺序存储结构<br>二叉树顺序存储结构用一组地址连续的存储单元（再具体的语言实现中用数组）存储二叉树。将二叉树结构的结点从上到下，从左到右依次存入某数组中[10]。数组下标既代表结点的编号又代表了结点之间的相互关系，这种结点之间的相互关系需要借助完全二叉树结构来反映。所以二叉树的顺序存储就是用数组存储一颗满二叉树或者完全二叉树，如果二叉树不是满二叉树或者完全二叉树结构，空余结点在数组中用0代替来形成完全二叉树的结构[10]。</p><p>图3-1　　二叉树的顺序存储结构<br>2链式存储结构<br>顺序存储结构在上面已经介绍，但是如果一棵树是单支树的情况下，顺序存储结构在数组中需要补充的结点太多，空间利用率太低。因此大部分二叉树都采用链式存储结构，链式存储结构就是用链表来存储二叉树。二叉链表至少包含三部分：数据域data、左指针域lchild、右指针域rchild。<br>表3-2　　二叉树链式存储结构的结点存储<br>lchild    data    rchild</p><pre><code>图3-2　　二叉链表的存储结构</code></pre><p>3.1.2　二元搜索树的查找算法<br>算法步骤：二叉排序树的查找是从根结点开始，沿着某一子树路径逐层向下比较的过程。<br>第一步：二叉排序树非空，将根结点的关键字和待查找值比较，如果两值相等，则查找成功。若不相等进行第二步。<br>第二步：若根结点的关键字&gt;待查找值时，在根结点的左子树中继续查找。<br>            若根结点的关键字&lt;待查找值时，在根结点的右子树中继续查找。<br>编码实现：<br>二叉树的构造：<br>typedef  struct BiTNode<br>{<br>    ElemType data;<br>    struct BiTNode <em>lchild, </em>rchild;<br>}BiTNode, <em>BiTree;<br>二叉树的建立，按前序遍历的方式建立二叉树。<br>void CreateBiTree(BiTree </em>T)<br>{<br>    ElemType ch;<br>    cin &gt;&gt; ch;<br>    if (ch == ‘#’)<br>        <em>T = NULL;<br>    else<br>    {        </em>T = (BiTree)malloc(sizeof(BiTNode));<br>        (<em>T)-&gt;data = ch;//生成结点<br>        CreateBiTree(&amp;(</em>T)-&gt;lchild);<br>        CreateBiTree(&amp;(*T)-&gt;rchild);<br> }<br>}<br>递归方式前序遍历二叉树：<br>void PreOrderTraverse(BiTree T, int level)<br>{<br>    if (T == NULL)<br>        return;<br>    operation2(T-&gt;data, level);<br>    PreOrderTraverse(T-&gt;lchild, level + 1);<br>    PreOrderTraverse(T-&gt;rchild, level + 1);<br>}<br>3.1.3　二元树的算例<br>本小节将通过实例，说明二元树的应用。<br>例3.1　二叉查找树的应用<br>1.问题的提出：<br>假设某大学的教授张美美。她对自己的名字很钟情，所以张老师想知道全校师生否有和她重名字的同学或者老师。<br>2.问题的分析：<br>张老师想做的就是在大量的数据中查找到是否有自己想到的目标数据，查找特定的名字，但是学校是会有人员的增加和减少的，比如新招聘了一些老师，或者某些老师调走。所以解决李老师的问题不光是在大量的数据中查找，还需要插入或者删除新的数据，在查找。<br>3.建立数学模型：<br>将学生看做结点，所有学生结点组成一个图。要查找图中结点，第一步需要将图中各名字结点按字典序排序，否则就是大海里面捞针一个一个挑。排序之后在大量的数据中查找，二分查找是最好的方法。第二步需要选取数据存储结构来存储数据。<br>注：为了举例我们以七个同学为数据代表.<br>假设一，按照数组结构存储数据结点：</p><pre><code>                 　图3-7 　　数组存储数据信息图</code></pre><p>假设二，按照链表结构存储数据结构：</p><pre><code>图3-8　　链表存储数据信息图</code></pre><p>假设三，按照二元搜索树结构存储：                  </p><pre><code>图3-9　　平衡二叉树存储数据信息图</code></pre><p>复杂度分析如下表３－３：<br>表3-3　　复杂度分析表<br>    查找复杂度    插入复杂度    删除复杂度<br>数组结构存储    0(1)    O()    O()<br>链表结构存储    O()    0(1)    0(1)<br>二元搜索树结构存储    0()    0()    0()</p><p>如表3-3所示，选取数组顺序存储数据时，查找的复杂度很小，但是插入删除的复杂度很高。因为每次插入删除元素时需要将结点元素放入对应位置。假设增加一位学生李爱军同学，那么需要将李爱军同学插入到李爱国和李帅帅之间，则插入李爱军，数组李帅帅之后的元素都需要向后移动一个位置。删除同理。所以插入删除的时间复杂度为O()。选取链表顺序存储数据结构时，每个结点数据都有一个指向后面结点的指针，通过指针进行插入删除很方便，每次只需要一定结点之间的指针就可以进行插入和删除。但是进行查找时需要一个一个遍历，时间复杂度为O()。选取二叉树的存储结构时，依据二元搜索树的查找算法时间复杂度都是0()。综上分析，选取二元树是最优的。如果构造二元树的过程中，构造的二叉树结构不是平衡二叉树时可以将其转化为平衡二叉树再进行查找。<br>4.模型的求解：<br>①首先可以判断二叉树非空，则继续进行。<br>②然后将张美美结点作为待查找结点与根结点李帅帅结点比较，在字典序中Z&gt;L,然后执行算法第二步，和根结点李帅帅结点的右孩子比较。<br>③然后张美美结点与王爱军结点比较，在字典序中Z&gt;W,,然后执行算法第二步，和王爱军结点的右孩子比较。<br>④然后张美美结点与张美美结点比较，在字典序中Z=Z,M=M,M=M,结点信息相同，查找成功。<br>例3.2　Huffman树的应用<br>1.问题的提出：<br>某实行封闭式管理的高中，为了提高学生成绩和专注力，提出严禁学生私自携带手机入校。为了配合新措施的施行以及方便家长和学生的沟通，学校在学生公寓配备了电话。每个寝室一部电话，但是每个楼层只有一根外线。如果有人往出打电话或者有电话打进的时候，都需要楼层的宿管转到内线，然后学生和家长才能沟通。假设三楼共有八个寝室301-308，各寝室使用电话的频率如下表3-4，那么怎么设计内线电话号码，才能使宿舍楼管效率最高即拨号次数最少呢？<br>表3-4　　寝室电话使用频率表<br>    寝301    寝302    寝303    寝304    寝305    寝306    寝307    寝308<br>频率（次/周）    5    10    6    15    27    11    20    2</p><p>2.问题的分析：<br>寝室内的电话需要宿管接线才可以和外界通话，内线电话的号码可以自己设置。将寝室电话看做结点，电话使用频率看做结点的权值。为了使接线员所拨打的号码最少。效率最高。可以将结点所对应的电话号码位数作为比较量，位数越少宿管接线员所拨打的号码就越少。提高效率的方法就是让使用频率高的电话号码少，使用频率低的电话号码多。将电话号码的使用频率作为结点的权值赋给结点，为了使总拨号次数最少，将电话号码设计为不等长的号码。拨打电话频率高的电话分配一个短的号码，拨打电话频率低的电话分配一个长的号码。构造Huffman树即可解决问题。<br>3.建立数学模型：<br>各寝室电话以权值为结点代表组成一个图，图中含有八个结点。按照Huffman树的构造算法构造Huffman树。构造步骤如下：<br>①将八个结点{2,5,6,10,11,15,20,27}存入图G中。<br>②将八个结点中权值最小的两个结点权值（2,5）相加组成一个新的结点（7），在图G中剔除2,5，加入7，更新图G。<br>重复第二步直到更新图G只剩下一个结点。<br>构造之后给结点的孩子定序，兄弟有序，左边的为兄（标0），右边为弟（标1）。在顶和顶之间的轨上标出0或者1.<br>构造Huffman树如图3-10</p><p>图3-10　　电话结点Huffman树结构图</p><p>从根始到叶的轨上依次记下各顶之码，即为电话号码。各寝室电话号码如下表3-5所示：<br>表3-5　　寝室-号码对应表<br>寝室    寝301（5）    寝302（10）    寝303（6）    寝304（15）    寝305（27）    寝306（11）    寝307（20）    寝308（2）<br>号码    11011    010    1100    111    10    011    00    11010<br>拨号次数    5    3    4    3    2    3    2    5</p><p>通过Huffman树可以求得拨号次数总权值：<br>4.模型的求解：<br>构造了Huffman树，因为Huffman树的叶子节点的权值就是电话的每星期拨打频率。只有叶子节点上面的权值影响求解结果，其他节点的权值只是作为构造Huffman树的辅助节点。由二叉树和Huffman树的性质可以得到叶子节点的个数=非叶节点个数+1。所以数据结构中有多少节点个数是已知的。在数据个数已知的情况下，可以考虑用连续的存储空间来存储节点数据。可以用一个结构体数组来存储节点。每个结构体数组中包含节点的权重，父亲节点，孩子节点等信息。在长度为2*n-1个连续存储空间中，前N个存储空间存放叶子节点的信息，后n-1个连续的存储空间存放非叶节点的信息。依次将节点插入到存储空间中从而来构造Huffman树结构。<br>3.1.4　小结<br>将图论中的二元树查找理论应用得到数据结构中来解决问题，首先将建立数学模型构造排序序列，然后构造二叉树的存储结构、依据二叉排序算法求解。二元搜索树以图论的理论为基础，通过计算机数据结构的知识，将图论中的树结构存储到计算机中，通过具体的语言实现算法。数组的搜索比较方便，可以直接使用下标，但删除或者插入就比较麻烦了，而链表与之相反，删除和插入都比较简单，但是查找很慢，这自然也与这两种数据结构的存储方式有关，数组是取一段相连的空间，而链表是每创建一个节点便取一个节点所需的空间，只是使用指针进行连接，空间上并不是连续的。而二叉树就既有链表的好处，又有数组的优点。</p><p>4　　网状图结构中的查找<br>本章主要讨论图论中的网状图结构中的查找。前面介绍了图论中树形结构查找结点是如何应用在数据结构中的，这章继续深入介绍图论在网状图结构中查找路径是如何应用在数据结构中的。以最小生成树为例，介绍图查找的应用，分析图搜索算法在数据结构中的应用。<br>4.1　图查找的应用<br>图搜索（GRAPHSEARCH）的一般过程如下：<br>①建立一个只含有起始结点S的搜索图G，图中每个节点有一个指向其父节点的指针, S的这一指针为一特殊值(如0), 并把S放到一个未扩展节点表OPEN中[4]。<br>②建立一个已扩展结点表CLOSED，其初始为空表[4]。<br>③LOOP:若OPEN表是空表，则失败退出。<br>④把OPEN表中的第一个节点移出,放入CLOSED表中,  称其为n节点[4]。<br>⑤若n为目标节点,则成功退出. 问题的解是沿指针 追踪G中从n到S的路径而得到的[4]。<br>⑥扩展节点n, 生成不是n的祖先的那些后继节点的集合M.如果没有后继节点,则转LOOP[4]。<br>⑦把那些不在G中的M的成员作为n的后继节点加入G,并设置一个通向n的指针,把它们加入OPEN表。 对已在G中的M的成员,调整有关指针[4]。<br>⑧按某一任意方式或按某一探测值, 重排OPEN表[4]。<br>⑨GO LOOP。</p><p>图4-1　　图搜索过程框图<br>以上的搜索过程可用图4-1的搜索程序框图来表示，这个过程一般包括很多具体的图搜索算法[4]。通过图搜索算法最终生成一个明确的图G（称为搜索图）和G的一个子集T（称为搜索树），树T上的每一个结点也在图G中[4]。对任何结点的单独一条路径可用T来定义：粗略的说，在OPEN表上的结点都是搜索图的端节点，在CLOSED表上的节点，或者是几个已被扩展但是在搜索树中没有生成后继节点的端节点，或者是搜索树的非终端节点。<br>4.2　最小生成树的查找<br>4.2.1　最小生成树的定义和性质<br>定义4.2.1.1[6] 在连通加权图上求一个总权最小的连通生成子图，显然这个最小的连通生成子图就是一个总权最小的生成树。<br>性质4.2.1：<br>（1）最小生成树不唯一，对一个带权连通无向图来说。它的所有生成树集合中可能有多个最小生成树，即他们的权值可能相同，树形不同；若带权无向图的边比顶点少1，此时它本身就是一棵树，即最小生成树是其本身。<br>（2）最小生成树权值相等且最小。<br>（3）边数+1=顶点数。<br>这里给出连通加权图中最小的连通生成子图就是总权最小的生成树。用反证法证明。<br>证明:<br>假设：H1是连通加权图H的总权最小的连通生成子图。<br>如果：H1不是生成树，则H1上必有圈C.<br>那么:从圈C上删去一条边，仍得连通生成子图H2.<br>但是此时H2的总权已经比H1的要小,这与H1是总权最小的连通生成子图相矛盾。所以:H1是生成树，并且权值最小。<br>4.2.2　最小生成树算法<br>　　求解最优树（即最小生成树）可以用很多方法求解，这里用图论中上经典的Kruskal算法，Kruskal算法是Kruskal在1956年设计的一个有效的求解连通加权图的最优树算法。<br>算法步骤[2]：<br>（1）从图中选一条权值最小的边。<br>（2）若已经选出，则从中选，使得<br>（i）中无圈。<br>（ii）。<br>（3）反复执行上述过程直到选出为止。<br>　　复杂度：Kruskal算法的时间复杂度为。<br>4.2.3　最小生成树算法在数据结构中的具体存储和实现<br>由于图论中的图结构是网状结构，在数据结构中的存储不能简单的用线性结构就能解决。目前解决网状图结构的存储在数据结构中主要有邻接矩阵、邻接表、十字链表、邻接多重表以及边集数组这六种存储结构。具体应用哪种存储结构要具体分析视情况而定。比如即使都是求解最小生成树，Prim算法因为对顶点为依托逐渐搜索，所以用邻接矩阵的存储结构更好。而Kruskal算法大量操作都是针对边而操作的，所以用边集数组是最优的。在搜索的时间复杂度和存储的空间复杂度上都是最好的选择。<br>构造两个一维数组edges[n],D[n].数组D用来存储图的顶点信息。数组edges用来存储图的边信息。每个数组edges中的元素都是一个结构体（如果在JAVA语言中就是一个对象），每个元素包括边的顶点，终点和边的权值。<br>边的结构体定义：<br>typedef struct<br>{<br>    int begin;<br>    int end;<br>    int weight;<br>  }Edge;<br>表4-1　　图4-2中的顶点数组D存储结构示意图<br>顶点    V1    V2    V3    V4    V5    V5<br>数组下标    0    1    2    3    4    5</p><p>表4-2　　图4-2中的边数组B存储结构示意图<br>边数组B    边顶点    边终点    边权重<br>B[0]=Edge1    V4    V5    2<br>B[1]=Edge2    V3    V6    4<br>B[2]=Edge3    V3    V4    6<br>B[3]=Edge4    V2    V6    9<br>B[4]=Edge5    V1    V5    11<br>B[5]=Edge6    V4    V6    13<br>B[6]=Edge7    V2    V3    15<br>B[7]=Edge8    V1    V2    20<br>B[7]=Edge9    V5    V6    32<br>B[8]=Edge0    V1    V6    45</p><p>最小生成树的算法实现：<br>/<em> 查找连线顶点的尾部下标 </em>/<br>int Find(int <em>par, int t)<br>{<br>        while (par[t] &gt; 0)<br>        f = par[t];<br>        return t;<br>}<br>/</em> 生成最小生成树 */<br> void MiniSpanTree_Kruskal(MGraph G)<br>{<br>        int i, j, n , m;<br>        int i, j, n , m;<br>        int k = 0;<br>        int par[MAXVEX];//定义一数组用来判断边与边是否形成环路<br>        Edge edges[MAXEDGE];//定义边集数组,edge的结构为begin,end,weight<br>        //此处不在赘述边的权值由小到大排序代码<br>        for (i = 0; i &lt; G.numVertexes; i++)<br>          par[i] = 0;<br>       cout &lt;&lt; “打印最小生成树：” &lt;&lt; endl;<br>       for (i = 0; i &lt; G.numEdges; i++)//循环边集判断是否形成回路<br>       {<br>          n = Find(par, edges[i].begin);<br>          m = Find(par, edges[i].end);<br>           if (n != m)//不形成回路<br>           {<br>              par[n] = m;//将此边的结尾顶点放入下标为起点的parent中<br>            //表示此顶点已经在生成树集合中<br>             cout &lt;&lt;edges[i].begin&lt;&lt;edges[i].end&lt;&lt;edges[i].weight&lt;&lt;endl;<br>          }<br>        }<br>}<br>4.2.4　最小生成树算例<br>本小节将通过现实生活中的实际应用，说明最小生成树在实际应用中的具体实现，以实际例子来说明图论在数据结构中的存储和实现。<br>1.提出问题：<br>这里我们给出一个实际问题的例子。通过分析图论方法和数据结构的方法解决实际问题的异同，来说明图论中最小生成树在数据结构的作用，以及在解决实际问题方面的作用。假设在雄安新区的城市建设中需要修筑一条能连接n各区的公路（双向），已知区和区间的公路造价为，设计一个道路规划连接图，使得总花费最低。<br>2.分析问题：<br>例图4-1是六个城区及彼此之间的距离。</p><p>图4-2　　雄安新区城市道路图</p><p>设各个公路修建过程中作用材料相同，且忽略诸如天气，人工费等一些随机因素，只考虑市区之间的距离，则城市间距离作为图中两个顶之间的权值。从图中选取一条能连接所有顶的路径，且路径权值最小即为所求。<br>3.建立数学模型：<br>将雄安新区的各个市区看做顶点，道路为连接各顶的边，是顶到顶之间边的权值，那么道路连接图实际上就是一个赋权无向图，而要想达到花费最低，实际上就是以城市为顶构作一个完全加权图，使成为最小生成树。<br>4.模型求解：<br>显然，所求即为连通赋权图的最小生成树.用Kruskal算法分析解决问题并不难，下面将图论中的Kruskal算法依据本题模型实现算法在数据结构中的模拟过程。用数据结构中的线性存储结构-数组resout[n]来存储最小生成树的结果集。<br>依据Kruskal算法:<br>第一步，从图4-1中所有的边中选出权值最小的边，权值最小为；e1符合算法要求，将边插入到结果集result中，得result[0]=e1。<br>第二步，从图4-1中剩下的边中选出权值最小的边选；边e2符合算法要求，结果集result中的边不构成连通图。将边e2插入到结果集result中,得result[1]=e2。<br>第三步，从图4-1中剩下的边中选出权值最小的边选；边e3符合算法要求，结果集result中的边不构成连通图。将边e3插入到结果集result中,得result[2]=e3。<br>第四步，从图4-1中剩下的边中选出权值最小的边选；边e4符合算法要求，结果集result中的边不构成连通图。将边e4插入到结果集result中,得result[3]=e4。<br>第五步，从图4-1中剩下的边中选出权值最小的边选；边e5符合算法要求，结果集result中的边不构成连通图。将边e5插入到结果集result中,得result[4]=e5。<br>此时六个城区均已连通且无回路，算法终止。result集合中依次存入了图4-3所示的最小生成树边集合。</p><p>图4-3　　最小生成树示意图</p><p>图4-3即为雄安新区城市道路规划图的最优解，可以求出总造价为32.<br>4.2.5　小结<br>例子的问题可以抽象为一类问题。即在一个网状图中有若干个顶点和连接各顶点的边，求解一条路径可以连接所有的顶点，并且路径的权值最小。这类问题就是求解最小生成树。Kruskal算法是基于贪心选择策略的。在图论中以边为参考单位，首先将各个边的权值按从小到大排序。然后选取权值最小的边作为最小生成树的第一条边。连接边的两个顶作为两个求解到的顶点。然后选择边权值排序中下一个优先级的边，此时从初始点沿路径开始判断，如果刚加入的边所形成的的图中有回路，则不选择此边，继续遍历。如果不形成回路，则选择此边，继续遍历。可见贪心算法求解最小生成树思想并不复杂。重点是数据存储结构的选取和算法的实现。这是图论应用在数据结构中最明显的应用。图论中的理论和算法早早的已经趋近于完善。但是如何将其完美的应用在数据结构中，如何使算法执行的时间复杂度和数据结构存储的空间复杂度都最小才是关键。这就是图论如何应用在数据结构中的范畴，我们研究图论目前在数据结构中的数据存储和算法实现就是为了以后图论能更多的应用在数据结构和算法中。</p><p>5　　总结与展望<br>5.1　总结<br>图论的起源较早，却在近些年来展现了蓬勃的生命力。最重要的原因就是图论理论大量应用在工程领域。图论在计算机中的应用最主要的体现就是在数据结构中的应用。但是，图论在数据结构中关于树形结构和网状图结构中的应用还不够全面。本文主要对树形结构，网状图结构进行讨论。通过列举几个关于查找的实例来说明图论理论是如何通过数据结构转化为计算机语言来解决问题的。现在的大学课程中，工科学生并不会学习图论的课程。众多图论的概念和算法掺杂在数据结构中，以至于很多人认为二元搜索树等是数据结构与生俱来的。实际上数据结构的很多概念和算法都是依据图论理论的。数据结构关注的重点应该是图论将抽象问题转化为图论问题之后所进行的：例如二叉树搜索树结构，依据图论中二元搜索树，数据结构需要解决用什么变量表示二叉树中图的顶和边，怎样将顶和边连接成一个完整的图形，怎样存储二叉树结构，以及如何实现二元搜索树算法。完整的剖析一个例子才能知道哪些是图论理论哪些是数据结构知识。这样对于很多图论中尚没有解决的问题，能否将其应用在数据结构中来解决就显得至关重要。对于那些以后的新知识，更广泛的说对于以后的新学科之间的互相应用都提供了借鉴意义。<br>5.2　展望<br>图论理论在近代数学中发挥了举足轻重的作用，这很大一部分得益于计算机的发展。和工程领域联系巨大的图论必然会随着人工智能，深度学习等新技术的发展而被人们更大范围更深层次的引用和研究。下一步应该重点对图理论中的树形结构和网状图结构在数据结构中关于查找的应用进行更为深入的研究。进而通过图理论优化查找算法的时间复杂度和空间复杂度。并且以图理论在数据结构中关于查找的应用为依托来研究图理论中树状图和网状图在数据结构和算法中关于数据的改变、数据的修改、数据的剔除等操作。图论指导并且应用到新兴技术上面会向图论在数据结构中的应用一样水乳交融，密不可分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1　　前言&lt;br&gt;图论是一门既古老又年轻的学科[1]，说它古老，是因为图论从产生到现在已经有200多年的历史了[1]；说它年轻，是因为近几十年来图论随着计算机技术的快速发展表现出了蓬勃的生命力。图论是数学很重要的一个分支。离散数学中大部分内容都来源于图论。其主要研究对象就是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>考研调剂总结</title>
    <link href="https://github.com/caymant/2018/04/11/%E8%80%83%E7%A0%94%E4%BB%A5%E5%8F%8A%E8%B0%83%E5%89%82%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/caymant/2018/04/11/考研以及调剂总结/</id>
    <published>2018-04-11T04:58:43.000Z</published>
    <updated>2018-06-30T01:31:46.350Z</updated>
    
    <content type="html"><![CDATA[<p>从考研到结束，一直到今天已经一年有余了，今天正式被在调剂系统上面看到自己被BNU拟录取，其实并没有什么高兴或者失落，奔波三月心里早早的疲惫了，不过一整个三月都在弄调剂的事情，总算有点收获。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从考研到结束，一直到今天已经一年有余了，今天正式被在调剂系统上面看到自己被BNU拟录取，其实并没有什么高兴或者失落，奔波三月心里早早的疲惫了，不过一整个三月都在弄调剂的事情，总算有点收获。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP/IP三次挥手四次分手</title>
    <link href="https://github.com/caymant/2018/02/11/TCP%20IP/"/>
    <id>https://github.com/caymant/2018/02/11/TCP IP/</id>
    <published>2018-02-11T04:58:43.000Z</published>
    <updated>2018-02-11T04:58:57.910Z</updated>
    
    <content type="html"><![CDATA[<p>###TCP协议的特点:###<br>    TCP是在不可靠的TP层之上实现的可靠的数据传输协议，主要解决传输的可靠、有序、无丢失和不重复的问题。TCP是TCP/IP体系中一个非常复杂的协议，主要特点有：<br>1)TCP是面向连接的传输层协议。<br>2）每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点（一对一的）。<br>3）TCP提供可靠的交付服务，保证传送的数据无差错，不丢失，不重复且有序。TCP提供全双工通信。<br>4）TCP是面向字节流的，TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。</p><p>###TCP连接管理：###<br>每一个TCP的连接都有三个阶段：连接简历，数据传送和连接释放。TCP连接的端口叫做套接字，socket，端口拼接到IP地址即构成了套接字。每一条TCP连接唯一的被通信两端的两个端点（即两个套接字）所确定。TCP连接的建立采用客户/服务器模式，主动的叫客户机，被动的叫服务器。!<img src="https://i.imgur.com/Zyzmqqr.jpg" alt=""><br>总结如下：<br>（1）连接建立 分为三步<br>1.SYN=1，seq=x.<br>2.SYN=1，ACK=1，seq=y,ack=x+1.<br>3.ACK=1,seq=x+1,ack=y+1.<br>(2)连接释放 分为四步<br>1.FIN=1，seq=u.<br>2.ACK=1,seq=v,ack=u+1.<br>3.FIN=1,ACK=1,SEQ=W,ACK=U+1.<br>4.ACK=1,SEQ=U+1,ACK=W+1.  (注意ACK,SYN,FIN一定等于1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###TCP协议的特点:###&lt;br&gt;    TCP是在不可靠的TP层之上实现的可靠的数据传输协议，主要解决传输的可靠、有序、无丢失和不重复的问题。TCP是TCP/IP体系中一个非常复杂的协议，主要特点有：&lt;br&gt;1)TCP是面向连接的传输层协议。&lt;br&gt;2）每一条TCP连
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ｈｅｘｏ</title>
    <link href="https://github.com/caymant/2018/02/07/hexo/"/>
    <id>https://github.com/caymant/2018/02/07/hexo/</id>
    <published>2018-02-07T11:33:43.000Z</published>
    <updated>2018-02-09T10:36:12.596Z</updated>
    
    <content type="html"><![CDATA[<p><font face="微软雅黑" color="black" size="6">Hexo</font><br>是这几天才接触的，折腾了两三天，还有好多可以优化的，百度并没有找到我用的主题的优化教程，等以后慢慢了解在慢慢优化，只要可以发论文自己记录一下假期刷算法题的体会就好。年后还需要买一个域名。facebook,和twitter还不能用，总之翻墙有关的现在都不能用，这里记录一下，还有弄一下评论区，以及搜索的那个小Bug。<br><br>在hexo中如果所修改的文件是Blog文件夹下面的，更改完要重新部署一下，在博客目录文件下面Git Bash:  hexo clean , hexo genarate, hexo deploy。就部署好了。可以hexo s开启服务后本地浏览。如果hexo更改的是特定的主题文件夹下面的内容，直接hexo s刷新界面就好，这块我也有点不确定，可能直接刷新界面就好。都不用重新启动。D:\blog\source这个文件夹下面放的是一些整体配置文章有关的，其实我现在感觉设置完主题之后大部分的操作就在这个文件夹下面就是。附加一个就是项目到底是干嘛的现在还不是很清楚。慢慢学习吧！<br>自己花费很多时间就为了有一个自己的博客，这几天都花费在配置博客上面了，并没有学习什么新的知识，算法题的计划得赶紧赶上。有时候充实起来，真的不用想前途。管他干嘛。学习的状态真的是还有点沉醉，昨天不知不觉就零点了。总之，不要忘了初心。建立这个博客是给自己一个经常总结自己的地方，希望自己不断学习，不断总结。１９年要加油啊！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font face=&quot;微软雅黑&quot; color=&quot;black&quot; size=&quot;6&quot;&gt;Hexo&lt;/font&gt;&lt;br&gt;是这几天才接触的，折腾了两三天，还有好多可以优化的，百度并没有找到我用的主题的优化教程，等以后慢慢了解在慢慢优化，只要可以发论文自己记录一下假期刷算法题的体会就好
      
    
    </summary>
    
    
  </entry>
  
</feed>
